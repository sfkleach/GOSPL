;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Title       :   NEWTOKENISER
;;; Version     :   1
;;; Author      :   Steve Knight
;;; Date        :   Sun Jun 26, 1988
;;; Modified    :   Wed Sep 09, 1993
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; This library exports the routine "newtokeniser".  This function takes
;;; a start-name & a state transition graph as input & delivers a
;;; tokeniser.  The tokeniser, given a character stream, returns a token
;;; stream.
;;;
;;; In particular, the description of the state-transition diagram is geared
;;; up for discriminating on characters.  Hence, this is only any good for
;;; tokenising character streams -- which is what it is designed for.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

/*
Note that an ELSE condition does not include a TERMIN condition.  This means
that TERMIN must always be written explicitly.
-- Graph Format -------------------------------------------------------

Graph   ::= list( Node )

Node    ::= [Name | list( Arc )]

Arc     ::= [Cond Move Dest <Act>]      <x> means optional

Cond    ::= "termin" | "else" | Pred

Pred    ::= String | Character | Procedure

Move    ::= "->" | "=>" | "*=>"

Dest    ::= Name | Procedure

Act     ::= Procedure
*/

compile_mode :pop11 +strict;
section;

;;; Converts a character repeater to an updateable character repeater.
;;; Note that null-characters (0) are converted to 256 to cope with
;;; Pop11's lack of 0-based indexing.
define lconstant newcharpushable( r );
    lvars
        procedure r,    ;;; character repeater (checked)
        p = false;      ;;; pushback buffer

    define lconstant procedure canpush();
        if p then
            sys_grbg_destpair( p ) -> p
        else
            lvars ch = r();
            unless  isinteger( ch )
            and     ch fi_>= 0
            and     ch fi_< 256
            or      ch == termin
            do
                if ch == 0 then
                    256
                else
                    mishap( 'Non-character generated by repeater', [^ch ^r] )
                endif
            else
                ch
            endunless
        endif
    enddefine;

    define updaterof canpush();
        conspair( p ) -> p
    enddefine;

    canpush
enddefine;

;;; Unique labels for jumping to when an illegal char is spotted & when
;;; an exit is required
lconstant
    illegal_char = 'illegal_char',
    exit_label = 'exit_label';

;;; Converts the various CONDITION types into a uniform representation, which
;;; is a string including the acceptable characters.
define lconstant string_of( pred, seen ); lvars pred, ch, seen;
    if pred.isinteger then
        string_of( consstring( pred, 1 ), seen )
    elseif pred.isstring then
        cons_with consstring {%
            for ch in pred using_subscriptor fast_subscrs do
                unless seen( ch ) do
                    ch ->> seen( ch )
                endunless
            endfor
        %}
    elseif pred.isprocedure then
        cons_with consstring {%
            fast_for ch from 0 to 255 do
                if pred( ch ) and not( seen( ch ) ) then
                    ch ->> seen( ch )
                endif
            endfor
        %}
    else
        mishap( 'INTERNAL ERROR: Invalid pred', [^pred] )
    endif;
enddefine;

define lconstant not_seen( seen ); lvars seen, ch;
    cons_with consstring {%
        fast_for ch from 0 to 255 do
            unless seen( ch ) do
                ch ->> seen( ch )
            endunless
        endfor
    %}
enddefine;

define lconstant makearc( cond, label, move, destination, action );
    lvars cond, label, move, destination, action;
    unless cond = nullstring do
        [^cond ^label ^move ^destination ^action]
    endunless
enddefine;

lconstant
    erase_move = "->",
    accept_move = "=>",
    pushback_move = "*=>";

define lconstant checkmove( m ) -> m; lvars m;
    unless
        m == erase_move or
        m == accept_move or
        m == pushback_move
    do
        mishap( 'Invalid move', [^m] )
    endunless
enddefine;

define lconstant checkdestination( d ) -> d; lvars d;
    unless d.isword or d.isprocedure do
        mishap( 'Invalid destination', [^d] )
    endunless
enddefine;

define lconstant checkaction( a ) -> a; lvars a;
    unless a.isprocedure do
        mishap( 'Invalid action', [^a] )
    endunless
enddefine;

;;; * Includes an action (default false)
;;; * Separates a termin-arc (default arc)
;;; * Converts all Preds into strings (a standard format)
;;; * Expands else-conditions into explicit strings
;;; * Ensures the string-conditions do not overlap
;;; * Checks that moves are in [-> => *=>]
define lconstant reformat_node( node ); lvars node;
    lvars seen = newproperty( [], 100, false, true );

    lvars ( name, arclist ) = node.dest;
    lvars terminarc = false;
    [%
        lvars arc, t, elsearc = false, cond, move, destination, action;
        for arc in arclist do
            if (arc.destlist ->> t) == 3 then
                checkdestination() -> destination;
                checkmove() -> move;
                -> cond;
                false -> action;
            elseif t == 4 then
                checkaction() -> action;
                checkdestination() -> destination;
                checkmove() -> move;
                -> cond;
            else
                mishap( 'Invalid arc format', [^arc] )
            endif;
            if cond == "termin" or cond == termin then
                ;;; makearc always returns a result when condition is termin
                makearc( termin, sysNEW_LABEL(), move, destination, action ) -> terminarc
            elseif cond == "else" or not( cond ) then
                makearc( not_seen( seen ), sysNEW_LABEL(), move, destination, action );
                true -> elsearc
            else
                makearc(
                    string_of( cond, seen ),
                    sysNEW_LABEL(),
                    move,
                    destination,
                    action
                )
            endif;
        endfor;
        unless elsearc then
            makearc( not_seen( seen ), sysNEW_LABEL(), "->", illegal_char, false )
        endunless;
    %] -> arclist;
    [
        ^name
        ^terminarc
        ^^arclist
    ]
enddefine;

define lconstant reformat_graph( g ); lvars g;
    maplist( g, reformat_node )
enddefine;

define lconstant applymapclass( n, mc ); lvars n, mc;
    mc( if n == 0 then 256 else n endif )
enddefine;

define updaterof applymapclass( v, n, mc ); lvars v, n, mc;
    v -> mc( if n == 0 then 256 else n endif )
enddefine;

;;; NEWCLASSTABLE takes a list of strings and returns a classtable & the
;;; maximum class allocated
define lconstant newclasstable( strlist ) -> numclasses -> mapclass;
    lvars strlist, str, ch, numclasses, mapclass;
    lvars table = newproperty( [], 100, 0, true );
    ;;; A somewhat odd trick is used here.  In order to uniquely identify each
    ;;; string in the list we allocate it a BIT (ie. a power of 2).  Thus the
    ;;; classes are identified by the *union of the strings* which turns into
    ;;; simple bit patterm (ie. integral) addition.
    lvars k = 1;
    for str in strlist do
        for ch in str using_subscriptor subscrs do
            k + ch.table -> ch.table;
        endfor;
        k + k -> k;
    endfor;
    lvars
        numclasses = 0,
        bits_to_class =
            newanyproperty(
                [], 100, 1, false,
                syshash, nonop =, false,
                false,
                procedure( k, p ); lvars k, p;
                    1 + numclasses ->> numclasses ->> p( k )
                endprocedure
            );
    {%
        lvars ch;
        for ch from 1 to 255 do
            ch.table.bits_to_class
        endfor;
        0.table.bits_to_class           ;;; 0 maps into 256
    %} -> mapclass;
enddefine;

;;; takes a reformatted graph & makes a class table from it
define lconstant makeclasstable( rg ); lvars rg;
    maplist( rg, procedure( x ); lvars x; x(3)(1) endprocedure ).newclasstable
enddefine;

define lconstant initlabels( n ); lvars n;
    {% repeat n times illegal_char endrepeat %}
enddefine;

define lconstant update_labels( lab, class, labels ); lvars lab, class, labels;
    lvars l = labels( class );
    unless l == illegal_char or l == lab do
        mishap( 'INTERNAL ERROR (overloaded character): Please report', [^class] )
    endunless;
    lab -> labels( class )
enddefine;

;;; The main action of this phase is to strip off the condition-strings and
;;; create the labels-vector.  This will be used to generate the JUMPTABLE.
define lconstant insert_classes_into_graph( rg, mapclass, numclasses );
    lvars rg, mapclass, numclasses;
    define lconstant procedure insert_classes_into_node( rnode ); lvars rnode;
        lvars labels = initlabels( numclasses );
        lvars ( name, terminarc, arclist ) = rnode.dest.dest;
        if terminarc then
            ;;; Remove -termin- condition (was only a placeholder to ensure
            ;;; uniform format)
            tl( terminarc ) -> terminarc;
        endif;
        [%
            lvars arc, ch;
            for arc in arclist do
                lvars ( str, rest ) = arc.dest;
                lvars lab = rest.hd;
                for ch in str using_subscriptor subscrs do
                    update_labels( lab, applymapclass( ch, mapclass) , labels )
                endfor;
                rest;
            endfor;
        %] -> arclist;
        [
            ^name
            ^labels
            ^terminarc
            ^^arclist
        ]
    enddefine;
    maplist( rg, insert_classes_into_node )
enddefine;

define lconstant plant_move( label, move, destination, action );
    lvars label, action, destination, move;
    dlocal pop_new_lvar_list;
    lvars exiting = destination.isprocedure;
    sysLABEL( label );
    if move == "->" then
        sysERASE( undef );
        unless exiting do
            sysCALL( "rep" )
        endunless
    elseif move == "=>" then
        sysPUSH( "count" );
        sysPUSHQ( 1 );
        sysCALL( "fi_+" );
        sysPOP( "count" );
        unless exiting do
            sysCALL( "rep" )
        endunless
    elseif move == "*=>" then
        if exiting then
            sysUCALL( "rep" );
        endif
    else
        mishap( 'INTERNAL ERROR: Invalid move escaped check', [^move] )
    endif;
    if action then
        lvars v = sysNEW_LVAR(), w;
        sysCALL( "stacklength" );
        sysPOP( v );
        unless exiting do
            sysNEW_LVAR() -> w;
            sysPOP( w );
        endunless;
        sysPUSH( "count" );
        sysCALLQ( action );
        sysCALL( "stacklength" );
        sysPUSH( v );
        sysCALL( "fi_-" );
        sysPOP( "count" );
        unless exiting do
            sysPUSH( w )
        endunless
    endif;
    if destination.isword or destination == illegal_char then
        sysGOTO( destination )
    elseif exiting then
        sysPUSH( "count" );
        sysCALLQ( destination );
        sysGOTO( exit_label );
    else
        mishap( 'INTERNAL ERROR: Invalid destination escaped check', [^destination] )
    endif;
enddefine;

;;; rrn = re-re-formatted node
define lconstant plant_node( rrn, mapclass ); lvars rrn, mapclass;
    lvars ( name, labels, terminarc, arclist ) = rrn.dest.dest.dest;
    sysLABEL( name );
    lvars jump_table_label = sysNEW_LABEL();

    sysPUSHS( undef ); sysPUSHQ( termin ); sysCALL( "==" );
    sysIFNOT( jump_table_label );
    if terminarc then
        plant_move( terminarc.explode )
    else
        sysGOTO( illegal_char )
    endif;
    sysLABEL( jump_table_label );
    sysPUSHS( undef ); sysPUSHQ( mapclass ); sysCALL( "fast_subscrv" );
    sysGO_ON( [% labels.explode %], false );
    lvars arc;
    for arc in arclist do
        plant_move( arc.explode )
    endfor;
enddefine;

;;; rrg = re-re-formatted graph.
;;; By now, the graph has considerably changed its form.  It is in a
;;; highly uniform format & the jumptable labels have been prepared.
define lconstant plant_graph( start, rrg, mapclass ); lvars start, rrg, mapclass;

    define lconstant procedure error( ch ); lvars ch;
        if ch == termin then
            mishap( 'Unexpected end of input', [] )
        else
            mishap(  'Unexpected character', [^ch] )
        endif
    enddefine;

    sysPROCEDURE( start, 1 );
    sysLVARS( "rep", 0 );
    sysLVARS( "count", 0 );
    sysPOP( "rep" );
    sysPUSHQ( 0 ); sysPOP( "count" );
    sysCALL( "rep" );
    sysGOTO( start );
    lvars rrn;
    for rrn in rrg do
        plant_node( rrn, mapclass )
    endfor;
    sysLABEL( illegal_char );
    sysCALLQ( error );
    sysLABEL( exit_label );
    sysENDPROCEDURE().sysPUSHQ;
enddefine;

define lconstant plant_tokeniser() with_nargs 3;
    procedure();
        plant_graph();
        sysEXECUTE()
    endprocedure.sysCOMPILE
enddefine;

define global newtokeniser( start, graph ); lvars start, graph;
    reformat_graph( graph ) -> graph;
    lvars ( mapclass, numclasses ) = makeclasstable( graph );
    insert_classes_into_graph( graph, mapclass, numclasses ) -> graph;
    lvars t = plant_tokeniser( start, graph, mapclass );
    procedure( cr, t ); lvars cr, t;
        t(% cr.newcharpushable %)
    endprocedure(% t %)
enddefine;

endsection;
